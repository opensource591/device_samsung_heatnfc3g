diff -ur CM11_loganxx/frameworks/av/include/media/stagefright/ColorConverter.h CM11_loganxxP/frameworks/av/include/media/stagefright/ColorConverter.h
--- CM11_loganxx/frameworks/av/include/media/stagefright/ColorConverter.h	2016-02-19 12:52:14.000000000 +0000
+++ CM11_loganxxP/frameworks/av/include/media/stagefright/ColorConverter.h	2016-01-08 01:53:32.000000000 +0000
@@ -78,6 +78,9 @@
 
     status_t convertCbYCrY(
             const BitmapParams &src, const BitmapParams &dst);
+			
+	status_t convertYCbYCr(
+            const BitmapParams &src, const BitmapParams &dst);		
 
     status_t convertYUV420Planar(
             const BitmapParams &src, const BitmapParams &dst);
diff -ur CM11_loganxx/frameworks/av/media/libstagefright/ACodec.cpp CM11_loganxxP/frameworks/av/media/libstagefright/ACodec.cpp
--- CM11_loganxx/frameworks/av/media/libstagefright/ACodec.cpp	2016-02-19 12:52:14.000000000 +0000
+++ CM11_loganxxP/frameworks/av/media/libstagefright/ACodec.cpp	2016-02-22 18:33:05.000000000 +0000
@@ -496,11 +496,11 @@
 
     status_t err;
     if (mNativeWindow != NULL && portIndex == kPortIndexOutput) {
-        if (mStoreMetaDataInOutputBuffers) {
-            err = allocateOutputMetaDataBuffers();
-        } else {
+    //    if (mStoreMetaDataInOutputBuffers) {
+    //        err = allocateOutputMetaDataBuffers();
+    //    } else {
             err = allocateOutputBuffersFromNativeWindow();
-        }
+    //    }
     } else {
         OMX_PARAM_PORTDEFINITIONTYPE def;
         InitOMXParams(&def);
@@ -654,11 +654,29 @@
             eHalHeight,
             eHalColorFormat);
 #else
+	
+	OMX_COLOR_FORMATTYPE HalColorFormat;
+	
+	ALOGI("PATCH:ACodec:configureOutputBuffersFromNativeWindow def.format.video.eColorFormat: %i", def.format.video.eColorFormat);
+	switch (def.format.video.eColorFormat) {
+		case OMX_COLOR_FormatYCbYCr:
+			ALOGI("PATCH:ACodec:configureOutputBuffersFromNativeWindow def.format.video.eColorFormat: OMX_COLOR_FormatYCbYCr (%i) -> (%i)", OMX_COLOR_FormatYCbYCr, (OMX_COLOR_FORMATTYPE)19);
+			def.format.video.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+			mOMX->setParameter(mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+			ALOGI("PATCH:ACodec:configureOutputBuffersFromNativeWindow def.format.video.eColorFormat: OMX_COLOR_FormatYCbYCr (%i) -> (%i) -> HAL_PIXEL_FORMAT_YV12 (%i)", OMX_COLOR_FormatYCbYCr, (OMX_COLOR_FORMATTYPE)19, (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12);
+			HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;	
+		break;
+		default:
+			ALOGI("PATCH:ACodec:configureOutputBuffersFromNativeWindow def.format.video.eColorFormat: default(%i) -> HAL_PIXEL_FORMAT_YV12 (%i)", def.format.video.eColorFormat, (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12);
+			HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;	
+		break;
+	}
+	
     err = native_window_set_buffers_geometry(
             mNativeWindow.get(),
             def.format.video.nFrameWidth,
             def.format.video.nFrameHeight,
-            def.format.video.eColorFormat);
+            HalColorFormat);
 #endif
 
     if (err != 0) {
@@ -1834,6 +1852,27 @@
     format.nIndex = 0;
     bool found = false;
 
+	if(format.eColorFormat == OMX_COLOR_FormatYCbYCr){
+		if (!strncmp(mComponentName.c_str(), "OMX.brcm.", 9)){
+			ALOGI("PATCH:ACodec:setVideoPortFormatType is brcm");
+			format.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+			status_t errs = mOMX->setParameter(mNode, OMX_IndexParamVideoPortFormat, &format, sizeof(format));
+				if (errs != OK){
+					ALOGE("PATCH:ACodec:setVideoPortFormatType setParameter failed: %d", errs);
+				}
+			ALOGI("PATCH:ACodec:setVideoPortFormatType format.eColorFormat set %i", format.eColorFormat);
+		}
+	}
+	ALOGI("PATCH:ACodec:setVideoPortFormatType End format.eColorFormat : %i", format.eColorFormat);
+	if(colorFormat == OMX_COLOR_FormatYCbYCr){
+		if (!strncmp(mComponentName.c_str(), "OMX.brcm.", 9)){
+			ALOGI("PATCH:ACodec:setVideoPortFormatType is brcm");
+			colorFormat = OMX_COLOR_FormatYUV420Planar;
+			ALOGI("PATCH:ACodec:setVideoPortFormatType colorFormat set %i", colorFormat);
+		}
+	}
+	ALOGI("PATCH:ACodec:setVideoPortFormatType End format.eColorFormat : %i", colorFormat);
+
     OMX_U32 index = 0;
     for (;;) {
         format.nIndex = index;
@@ -1875,6 +1914,17 @@
     if (!found) {
         return UNKNOWN_ERROR;
     }
+	
+	ALOGI("PATCH:ACodec:setVideoPortFormatType : %i", format.eColorFormat);
+	
+	if(format.eColorFormat == OMX_COLOR_FormatYCbYCr){
+		if (!strncmp(mComponentName.c_str(), "OMX.brcm.", 9)){
+			ALOGI("PATCH:ACodec:setVideoPortFormatType is brcm");
+			format.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+			ALOGI("PATCH:ACodec:setVideoPortFormatType set %i", format.eColorFormat);
+		}
+	}
+	ALOGI("PATCH:ACodec:setVideoPortFormatType end : %i", format.eColorFormat);
 
     status_t err = mOMX->setParameter(
             mNode, OMX_IndexParamVideoPortFormat,
@@ -1892,9 +1942,25 @@
     status_t err = mOMX->getParameter(
             mNode, OMX_IndexParamVideoPortFormat,
             &format, sizeof(format));
+	
+	ALOGI("PATCH:ACodec:setSupportedOutputFormat : %i", format.eColorFormat);
+	
     CHECK_EQ(err, (status_t)OK);
     CHECK_EQ((int)format.eCompressionFormat, (int)OMX_VIDEO_CodingUnused);
 
+	if(format.eColorFormat == OMX_COLOR_FormatYCbYCr){
+		if (!strncmp(mComponentName.c_str(), "OMX.brcm.", 9)){
+			ALOGI("PATCH:ACodec:setSupportedOutputFormat is brcm");
+			format.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+			status_t errs = mOMX->setParameter(mNode, OMX_IndexParamVideoPortFormat, &format, sizeof(format));
+				if (errs != OK){
+					ALOGE("PATCH:ACodec:setSupportedOutputFormat setParameter failed: %d", errs);
+				}
+			ALOGI("PATCH:ACodec:setSupportedOutputFormat format.eColorFormat set %i", format.eColorFormat);
+		}
+	}
+	ALOGI("PATCH:ACodec:setSupportedOutputFormat end : %i", format.eColorFormat);
+	
     return mOMX->setParameter(
             mNode, OMX_IndexParamVideoPortFormat,
             &format, sizeof(format));
@@ -2589,9 +2655,24 @@
 
     CHECK_EQ(err, (status_t)OK);
 
+	ALOGI("PATCH:ACodec:setVideoFormatOnPort: %i", def.format.video.eColorFormat);
+	
+	if(def.format.video.eColorFormat == OMX_COLOR_FormatYCbYCr){
+		if (!strncmp(mComponentName.c_str(), "OMX.brcm.", 9)){
+			ALOGI("PATCH:ACodec:setVideoFormatOnPort set %i", OMX_COLOR_FormatYUV420Planar);
+			def.format.video.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+			status_t errs = mOMX->setParameter(mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+			if (errs != OK){
+				ALOGE("PATCH:ACodec:setVideoFormatOnPort setParameter failed: %d", errs);
+			}
+		}		
+	}
+	
+	ALOGI("PATCH:ACodec:setVideoFormatOnPort: %i end", def.format.video.eColorFormat);
+
     if (portIndex == kPortIndexInput) {
         // XXX Need a (much) better heuristic to compute input buffer sizes.
-        const size_t X = 64 * 1024;
+        const size_t X = 64 * 8 * 1024;
         if (def.nBufferSize < X) {
             def.nBufferSize = X;
         }
diff -ur CM11_loganxx/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp CM11_loganxxP/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp
--- CM11_loganxx/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp	2016-02-19 12:52:14.000000000 +0000
+++ CM11_loganxxP/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp	2016-02-22 18:40:01.000000000 +0000
@@ -55,6 +55,7 @@
     switch (mSrcFormat) {
         case OMX_COLOR_FormatYUV420Planar:
         case OMX_COLOR_FormatCbYCrY:
+		case OMX_COLOR_FormatYCbYCr:
         case OMX_QCOM_COLOR_FormatYVU420SemiPlanar:
         case OMX_COLOR_FormatYUV420SemiPlanar:
         case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar:
@@ -130,6 +131,10 @@
             err = convertCbYCrY(src, dst);
             break;
 
+		case OMX_COLOR_FormatYCbYCr:
+            err = convertYCbYCr(src, dst);
+            break;	
+
         case OMX_QCOM_COLOR_FormatYVU420SemiPlanar:
             err = convertQCOMYUV420SemiPlanar(src, dst);
             break;
@@ -187,6 +192,71 @@
 
             signed u_b = u * 517;
             signed u_g = -u * 100;
+            signed v_g = -v * 208;
+            signed v_r = v * 409;
+
+            signed tmp1 = y1 * 298;
+            signed b1 = (tmp1 + u_b) / 256;
+            signed g1 = (tmp1 + v_g + u_g) / 256;
+            signed r1 = (tmp1 + v_r) / 256;
+
+            signed tmp2 = y2 * 298;
+            signed b2 = (tmp2 + u_b) / 256;
+            signed g2 = (tmp2 + v_g + u_g) / 256;
+            signed r2 = (tmp2 + v_r) / 256;
+
+            uint32_t rgb1 =
+                ((kAdjustedClip[r1] >> 3) << 11)
+                | ((kAdjustedClip[g1] >> 2) << 5)
+                | (kAdjustedClip[b1] >> 3);
+
+            uint32_t rgb2 =
+                ((kAdjustedClip[r2] >> 3) << 11)
+                | ((kAdjustedClip[g2] >> 2) << 5)
+                | (kAdjustedClip[b2] >> 3);
+
+            if (x + 1 < src.cropWidth()) {
+                *(uint32_t *)(&dst_ptr[x]) = (rgb2 << 16) | rgb1;
+            } else {
+                dst_ptr[x] = rgb1;
+            }
+        }
+
+        src_ptr += src.mWidth * 2;
+        dst_ptr += dst.mWidth;
+    }
+
+    return OK;
+}
+
+status_t ColorConverter::convertYCbYCr(
+        const BitmapParams &src, const BitmapParams &dst) {
+		ALOGE("PATCH:ColorConverter:convertYCbYCr");
+    // XXX Untested
+
+    uint8_t *kAdjustedClip = initClip();
+
+    if (!((src.mCropLeft & 1) == 0
+        && src.cropWidth() == dst.cropWidth()
+        && src.cropHeight() == dst.cropHeight())) {
+        return ERROR_UNSUPPORTED;
+    }
+
+    uint16_t *dst_ptr = (uint16_t *)dst.mBits
+        + dst.mCropTop * dst.mWidth + dst.mCropLeft;
+
+    const uint8_t *src_ptr = (const uint8_t *)src.mBits
+        + (src.mCropTop * dst.mWidth + src.mCropLeft) * 2;
+
+    for (size_t y = 0; y < src.cropHeight(); ++y) {
+        for (size_t x = 0; x < src.cropWidth(); x += 2) {
+			 signed y1 = (signed)src_ptr[2 * x ] - 16;
+            signed y2 = (signed)src_ptr[2 * x + 2] - 16;
+            signed u = (signed)src_ptr[2 * x + 1] - 128;  
+            signed v = (signed)src_ptr[2 * x + 3] - 128;
+
+            signed u_b = u * 517;
+            signed u_g = -u * 100;
             signed v_g = -v * 208;
             signed v_r = v * 409;
 
diff -ur CM11_loganxx/frameworks/av/media/libstagefright/colorconversion/SoftwareRenderer.cpp CM11_loganxxP/frameworks/av/media/libstagefright/colorconversion/SoftwareRenderer.cpp
--- CM11_loganxx/frameworks/av/media/libstagefright/colorconversion/SoftwareRenderer.cpp	2016-02-19 12:52:14.000000000 +0000
+++ CM11_loganxxP/frameworks/av/media/libstagefright/colorconversion/SoftwareRenderer.cpp	2016-02-22 18:41:23.000000000 +0000
@@ -208,8 +208,8 @@
         }
 
         for (int y = 0; y < (mCropHeight + 1) / 2; ++y) {
-            memcpy(dst_u, src_u, (mCropWidth + 1) / 2);
-            memcpy(dst_v, src_v, (mCropWidth + 1) / 2);
+			 memcpy(dst_u, src_v, (mCropWidth + 1) / 2);
+            memcpy(dst_v, src_u, (mCropWidth + 1) / 2);
 
             src_u += mWidth / 2;
             src_v += mWidth / 2;
diff -ur CM11_loganxx/frameworks/av/media/libstagefright/OMXCodec.cpp CM11_loganxxP/frameworks/av/media/libstagefright/OMXCodec.cpp
--- CM11_loganxx/frameworks/av/media/libstagefright/OMXCodec.cpp	2016-02-19 12:52:14.000000000 +0000
+++ CM11_loganxxP/frameworks/av/media/libstagefright/OMXCodec.cpp	2016-02-22 18:38:54.000000000 +0000
@@ -1799,6 +1799,19 @@
         CHECK_EQ(err, (status_t)OK);
         CHECK_EQ((int)format.eCompressionFormat, (int)OMX_VIDEO_CodingUnused);
 
+		if (format.eColorFormat == OMX_COLOR_FormatYCbYCr) {
+			ALOGI("PATCH:OMXCodec:setVideoOutputFormat: OMX_COLOR_FormatYCbYCr");
+			if (!strncmp(mComponentName, "OMX.brcm.", 9)){
+				ALOGI("PATCH:OMXCodec:setVideoOutputFormat: OMX.brcm.");
+				format.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+				ALOGI("PATCH:OMXCodec:setVideoOutputFormat: OMX_COLOR_FormatYCbYCr -> OMX_COLOR_FormatYUV420Planar");
+				status_t errs = mOMX->setParameter(mNode, OMX_IndexParamVideoPortFormat, &format, sizeof(format));
+				if (errs != OK){
+					ALOGE("PATCH:OMXCodec:setVideoOutputFormat: setParameter failed: %d", errs);
+				}
+			}
+        }
+
 #if 0
         CHECK(format.eColorFormat == OMX_COLOR_FormatYUV420Planar
                || format.eColorFormat == OMX_COLOR_FormatYUV420SemiPlanar
@@ -1866,11 +1879,11 @@
 
 #if 1
     // XXX Need a (much) better heuristic to compute input buffer sizes.
-#ifdef USE_SAMSUNG_COLORFORMAT
+//#ifdef USE_SAMSUNG_COLORFORMAT
     const size_t X = 64 * 8 * 1024;
-#else
-    const size_t X = 64 * 1024;
-#endif
+//#else
+//    const size_t X = 64 * 1024;
+//#endif
     if (def.nBufferSize < X) {
         def.nBufferSize = X;
     }
@@ -2428,11 +2441,37 @@
             def.format.video.nSliceHeight,
             eHalColorFormat);
 #else
+	
+	OMX_COLOR_FORMATTYPE HalColorFormat;
+	status_t errss;
+	
+	ALOGI("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow def.format.video.eColorFormat: %i", def.format.video.eColorFormat);
+	switch (def.format.video.eColorFormat) {
+		case OMX_COLOR_FormatYCbYCr:
+			ALOGI("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow OMX_COLOR_FormatYCbYCr(%i) -> (%i)", OMX_COLOR_FormatYCbYCr, (OMX_COLOR_FORMATTYPE)19);
+			ALOGI("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow OMX_COLOR_FormatYCbYCr(%i) -> HAL_PIXEL_FORMAT_YV12(%i)", OMX_COLOR_FormatYCbYCr, (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12);
+			def.format.video.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+			errss = mOMX->setParameter(mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+			if (errss != OK){
+				ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow setParameter failed: %d", errss);
+			}		
+			HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;
+		break;
+		case OMX_COLOR_FormatYUV420Planar:
+			ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow OMX_COLOR_FormatYUV420Planar(%i) -> HAL_PIXEL_FORMAT_YV12(%i)", OMX_COLOR_FormatYUV420Planar, (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12);
+			HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;
+		break;
+		default:
+			ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow default(%i) -> default(%i)", def.format.video.eColorFormat, def.format.video.eColorFormat);
+			HalColorFormat = def.format.video.eColorFormat;
+		break;
+	}
+
     err = native_window_set_buffers_geometry(
             mNativeWindow.get(),
             def.format.video.nFrameWidth,
             def.format.video.nFrameHeight,
-            def.format.video.eColorFormat);
+            HalColorFormat);
 #endif
 #else
     OMX_COLOR_FORMATTYPE eColorFormat;
@@ -6268,6 +6307,8 @@
 
     for (size_t c = 0; c < matchingCodecs.size(); c++) {
         const char *componentName = matchingCodecs.itemAt(c).mName.string();
+		
+		 ALOGI("PATCH:QueryCodecs: %s", componentName);
 
         results->push();
         CodecCapabilities *caps = &results->editItemAt(results->size() - 1);
@@ -6345,9 +6386,29 @@
         if (err != OK) {
             break;
         }
-        caps->mColorFormats.push(portFormat.eColorFormat);
-    }
-
+		ALOGI("PATCH:QueryCodec->OMX_VIDEO_PARAM_PORTFORMATTYPE:Begin portFormat.eColorFormat = %i, componentName = %s", portFormat.eColorFormat, componentName);
+		if (portFormat.eColorFormat == OMX_COLOR_FormatYCbYCr) {
+			ALOGI("PATCH:QueryCodec->OMX_VIDEO_PARAM_PORTFORMATTYPE: OMX_COLOR_FormatYCbYCr");
+			if (!strncmp(componentName, "OMX.brcm.", 9)){
+				ALOGI("PATCH:QueryCodec->OMX_VIDEO_PARAM_PORTFORMATTYPE (%s)", componentName);
+				portFormat.eColorFormat	= OMX_COLOR_FormatYUV420Planar;
+				ALOGI("PATCH:QueryCodec->OMX_VIDEO_PARAM_PORTFORMATTYPE portFormat.eColorFormat(%i)", portFormat.eColorFormat);
+				status_t errs = omx->setParameter(node, OMX_IndexParamVideoPortFormat, &portFormat, sizeof(portFormat));
+				if (errs != OK){
+					ALOGE("PATCH:QueryCodec->OMX_VIDEO_PARAM_PORTFORMATTYPE setParameter failed: %d", errs);
+				}
+				caps->mColorFormats.push(OMX_COLOR_FormatYUV420Planar);
+			}else{
+				ALOGI("PATCH:QueryCodec->OMX_VIDEO_PARAM_PORTFORMATTYPE color is YCbYCr but not brcm (%s)", componentName);
+				caps->mColorFormats.push(portFormat.eColorFormat);
+			}
+		}else{
+			ALOGI("PATCH:QueryCodec->OMX_VIDEO_PARAM_PORTFORMATTYPE color not YCbYCr (%i)", portFormat.eColorFormat);
+			caps->mColorFormats.push(portFormat.eColorFormat);
+		}
+		ALOGI("PATCH:QueryCodec->OMX_VIDEO_PARAM_PORTFORMATTYPE:End portFormat.eColorFormat = %i, componentName = %s", portFormat.eColorFormat, componentName);	
+   }
+	
     if (!isEncoder && !strncmp(mime, "video/", 6)) {
         if (omx->storeMetaDataInBuffers(
                     node, 1 /* port index */, OMX_TRUE) == OK ||
diff -ur CM11_loganxx/frameworks/base/services/java/com/android/server/power/PowerManagerService.java CM11_loganxxP/frameworks/base/services/java/com/android/server/power/PowerManagerService.java
--- CM11_loganxx/frameworks/base/services/java/com/android/server/power/PowerManagerService.java	2016-02-19 12:52:22.000000000 +0000
+++ CM11_loganxxP/frameworks/base/services/java/com/android/server/power/PowerManagerService.java	2016-02-22 18:45:44.000000000 +0000
@@ -247,6 +247,7 @@
     // Timestamp of the last call to user activity.
     private long mLastUserActivityTime;
     private long mLastUserActivityTimeNoChangeLights;
+	 private long mLastButtonActivityTime;
 
     // A bitfield that summarizes the effect of the user activity timer.
     // A zero value indicates that the user activity timer has expired.
@@ -1145,6 +1146,10 @@
                 return true;
             }
         } else {
+			 if (eventTime > mLastButtonActivityTime && (event & PowerManager.USER_ACTIVITY_EVENT_BUTTON) != 0) {
+                    mLastButtonActivityTime = eventTime;
+                    mDirty |= DIRTY_USER_ACTIVITY;
+            }
             if (eventTime > mLastUserActivityTime) {
                 mLastUserActivityTime = eventTime;
                 mDirty |= DIRTY_USER_ACTIVITY;
@@ -1735,7 +1740,7 @@
                         }
 
                         mKeyboardLight.setBrightness(mKeyboardVisible ? keyboardBrightness : 0);
-                        if (mButtonTimeout != 0 && now > mLastUserActivityTime + mButtonTimeout) {
+                        if (mButtonTimeout != 0 && now > mLastButtonActivityTime + mButtonTimeout) {
                             mButtonsLight.setBrightness(0);
                         } else {
                             mButtonsLight.setBrightness(buttonBrightness);
@@ -2666,8 +2671,9 @@
         if (reason == null) {
             reason = "";
         }
-        long duration;
-        if (reason.equals(PowerManager.REBOOT_RECOVERY)) {
+		 Log.e(TAG, "Reboot to recovery");
+		 SystemProperties.set("sys.powerctl", "reboot," + reason);
+		 Log.e(TAG, "Reboot to recovery sys.powerctl ok");
             // If we are rebooting to go into recovery, instead of
             // setting sys.powerctl directly we'll start the
             // pre-recovery service which will do some preparation for
@@ -2676,15 +2682,11 @@
             // This preparation can take more than 20 seconds if
             // there's a very large update package, so lengthen the
             // timeout.
-            SystemProperties.set("ctl.start", "pre-recovery");
-            duration = 120 * 1000L;
-        } else {
-            SystemProperties.set("sys.powerctl", "reboot," + reason);
-            duration = 20 * 1000L;
-        }
         try {
-            Thread.sleep(duration);
+			 Log.e(TAG, "Reboot to recovery sleep(20000)");
+		     Thread.sleep(20000);
         } catch (InterruptedException e) {
+			 Log.e(TAG, "Reboot to recovery interrupt");
             Thread.currentThread().interrupt();
         }
     }
diff -ur CM11_loganxx/frameworks/base/telephony/java/android/telephony/MSimTelephonyManager.java CM11_loganxxP/frameworks/base/telephony/java/android/telephony/MSimTelephonyManager.java
--- CM11_loganxx/frameworks/base/telephony/java/android/telephony/MSimTelephonyManager.java	2016-02-19 12:52:22.000000000 +0000
+++ CM11_loganxxP/frameworks/base/telephony/java/android/telephony/MSimTelephonyManager.java	2016-02-22 18:47:57.000000000 +0000
@@ -957,35 +957,11 @@
      * @hide
      */
     public static void setTelephonyProperty(String property, int index, String value) {
-        String propVal = "";
-        String p[] = null;
-        String prop = SystemProperties.get(property);
-
-        if (value == null) {
-            value = "";
-        }
-
-        if (prop != null) {
-            p = prop.split(",");
-        }
-
-        if (index < 0) return;
-
-        for (int i = 0; i < index; i++) {
-            String str = "";
-            if ((p != null) && (i < p.length)) {
-                str = p[i];
-            }
-            propVal = propVal + str + ",";
+        if (index != 0) {
+            property += "_" + index;
         }
 
-        propVal = propVal + value;
-        if (p != null) {
-            for (int i = index+1; i < p.length; i++) {
-                propVal = propVal + "," + p[i];
-            }
-        }
-        SystemProperties.set(property, propVal);
+        SystemProperties.set(property, value);
     }
 
     /**
@@ -994,16 +970,10 @@
      * @hide
      */
     public static String getTelephonyProperty(String property, int index, String defaultVal) {
-        String propVal = null;
-        String prop = SystemProperties.get(property);
-
-        if ((prop != null) && (prop.length() > 0)) {
-            String values[] = prop.split(",");
-            if ((index >= 0) && (index < values.length) && (values[index] != null)) {
-                propVal = values[index];
-            }
+        if (index != 0) {
+            property += "_" + index;
         }
-        return propVal == null ? defaultVal : propVal;
+		 return SystemProperties.get(property, defaultVal);
     }
 
     /**
diff -ur CM11_loganxx/frameworks/native/libs/gui/SensorEventQueue.cpp CM11_loganxxP/frameworks/native/libs/gui/SensorEventQueue.cpp
--- CM11_loganxx/frameworks/native/libs/gui/SensorEventQueue.cpp	2016-02-19 12:52:24.000000000 +0000
+++ CM11_loganxxP/frameworks/native/libs/gui/SensorEventQueue.cpp	2016-02-22 18:49:17.000000000 +0000
@@ -128,8 +128,12 @@
 
 status_t SensorEventQueue::enableSensor(int32_t handle, int32_t samplingPeriodUs,
                                         int maxBatchReportLatencyUs, int reservedFlags) const {
-    return mSensorEventConnection->enableDisable(handle, true, us2ns(samplingPeriodUs),
+    status_t err = mSensorEventConnection->enableDisable(handle, true, us2ns(samplingPeriodUs),
                                                  us2ns(maxBatchReportLatencyUs), reservedFlags);
+    if (err == NO_ERROR) {
+        mSensorEventConnection->setEventRate(handle, us2ns(samplingPeriodUs));
+    }
+    return err;
 }
 
 status_t SensorEventQueue::flush() const {
diff -ur CM11_loganxx/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp CM11_loganxxP/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp
--- CM11_loganxx/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp	2016-02-19 12:52:24.000000000 +0000
+++ CM11_loganxxP/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp	2016-01-08 01:53:32.000000000 +0000
@@ -1234,13 +1234,18 @@
         //getLayer()->compositionType = HWC_FRAMEBUFFER;
     }
     virtual void setPlaneAlpha(uint8_t alpha) {
+	// HAWAII_HWC does not respect planeAlpha despite being v1.2
+	#ifndef HAWAII_HWC
         if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_2)) {
             getLayer()->planeAlpha = alpha;
         } else {
+	#endif	
             if (alpha < 0xFF) {
                 getLayer()->flags |= HWC_SKIP_LAYER;
             }
+	#ifndef HAWAII_HWC		
         }
+	#endif	
     }
     virtual void setDefaultState() {
         hwc_layer_1_t* const l = getLayer();
diff -ur CM11_loganxx/frameworks/native/services/surfaceflinger/Layer.cpp CM11_loganxxP/frameworks/native/services/surfaceflinger/Layer.cpp
--- CM11_loganxx/frameworks/native/services/surfaceflinger/Layer.cpp	2016-02-19 12:52:24.000000000 +0000
+++ CM11_loganxxP/frameworks/native/services/surfaceflinger/Layer.cpp	2016-02-22 18:50:11.000000000 +0000
@@ -1260,6 +1260,8 @@
 
 void Layer::updateTransformHint(const sp<const DisplayDevice>& hw) {
     uint32_t orientation = 0;
+	// HAWAII_HWC has display problem in landscape mode when transform is used
+	#ifndef HAWAII_HWC
     if (!mFlinger->mDebugDisableTransformHint) {
         // The transform hint is used to improve performance, but we can
         // only have a single transform hint, it cannot
@@ -1270,6 +1272,7 @@
             orientation = 0;
         }
     }
+	#endif
     mSurfaceFlingerConsumer->setTransformHint(orientation);
     mTransformHint = orientation;
 }
diff -ur CM11_loganxx/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp CM11_loganxxP/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
--- CM11_loganxx/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp	2016-02-19 12:52:24.000000000 +0000
+++ CM11_loganxxP/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp	2016-02-22 18:51:21.000000000 +0000
@@ -1162,6 +1162,7 @@
             sp<const DisplayDevice> hw(mDisplays[dpy]);
             const int32_t id = hw->getHwcDisplayId();
             if (id >= 0) {
+			#ifdef QCOM_HARDWARE
                 // Get the layers in the current drawying state
                 const LayerVector& layers(mDrawingState.layersSortedByZ);
                 bool freezeSurfacePresent = false;
@@ -1181,6 +1182,7 @@
                         }
                     }
                 }
+			#endif
 
                 const Vector< sp<Layer> >& currentLayers(
                     hw->getVisibleLayersSortedByZ());
@@ -1194,6 +1196,7 @@
                      */
                     const sp<Layer>& layer(currentLayers[i]);
                     layer->setPerFrameData(hw, *cur);
+			#ifdef QCOM_HARDWARE		
                     if(freezeSurfacePresent) {
                         // if freezeSurfacePresent, set ANIMATING flag
                         cur->setAnimating(true);
@@ -1218,6 +1221,7 @@
                             lastSurfaceViewLayer = layer;
                         }
                     }
+			#endif
                 }
             }
         }
@@ -3392,6 +3396,11 @@
 {
     ATRACE_CALL();
 
+	// Rotation artifact problems when useReadPixels is false
+	#ifdef HAWAII_HWC
+    useReadPixels = true;
+	#endif
+
     // get screen geometry
     const uint32_t hw_w = hw->getWidth();
     const uint32_t hw_h = hw->getHeight();
diff -ur CM11_loganxx/frameworks/opt/telephony/src/java/com/android/internal/telephony/ExtCallManager.java CM11_loganxxP/frameworks/opt/telephony/src/java/com/android/internal/telephony/ExtCallManager.java
--- CM11_loganxx/frameworks/opt/telephony/src/java/com/android/internal/telephony/ExtCallManager.java	2016-02-19 12:52:25.000000000 +0000
+++ CM11_loganxxP/frameworks/opt/telephony/src/java/com/android/internal/telephony/ExtCallManager.java	2016-02-22 18:54:50.000000000 +0000
@@ -334,6 +334,16 @@
             case RINGING:
                 if (VDBG) Rlog.d(LOG_TAG, "setAudioMode RINGING");
                 int curAudioMode = mAudioManager.getMode();
+				// HACK: When Dual-SIM is enabled and call waiting occurs,
+                // com.android.phone.CallCommandService.setActiveSubscription
+                // will cause setAudioMode to be called, causing the audio
+                // mode to be chagned to "MODE_RINGTONE", rendering the active
+                // conversation to be inaudiable.
+                // (The setAudioMode() call does not occur without Dual-SIM.)
+                if (curAudioMode == AudioManager.MODE_IN_CALL) {
+					Rlog.d(LOG_TAG, "Skip MODE_IN_CALL -> MODE_RINGTONE (assume call waiting)");
+                    return;
+                }
                 if (curAudioMode != AudioManager.MODE_RINGTONE) {
                     // only request audio focus if the ringtone is going to be heard
                     if (mAudioManager.getStreamVolume(AudioManager.STREAM_RING) > 0
diff -ur CM11_loganxx/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java CM11_loganxxP/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java
--- CM11_loganxx/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java	2016-02-19 12:52:25.000000000 +0000
+++ CM11_loganxxP/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java	2016-02-22 18:55:14.000000000 +0000
@@ -150,6 +150,7 @@
     boolean mDnsCheckDisabled;
     public DcTrackerBase mDcTracker;
     boolean mDoesRilSendMultipleCallRing;
+	boolean mDoesRilSendCallRing;
     int mCallRingContinueToken;
     int mCallRingDelay;
     public boolean mIsTheCurrentActivePhone = true;
@@ -329,6 +330,11 @@
                 TelephonyProperties.PROPERTY_RIL_SENDS_MULTIPLE_CALL_RING, true);
         Rlog.d(LOG_TAG, "mDoesRilSendMultipleCallRing=" + mDoesRilSendMultipleCallRing);
 
+		 // Some RIL do not even send a single RIL_UNSOL_CALL_RING
+        mDoesRilSendCallRing = SystemProperties.getBoolean(
+                "ro.telephony.call_ring", true);
+        Rlog.d(LOG_TAG, "mDoesRilSendCallRing=" + mDoesRilSendCallRing);
+		
         mCallRingDelay = SystemProperties.getInt(
                 TelephonyProperties.PROPERTY_CALL_RING_DELAY, 3000);
         Rlog.d(LOG_TAG, "mCallRingDelay=" + mCallRingDelay);
@@ -1381,6 +1387,18 @@
     protected void notifyNewRingingConnectionP(Connection cn) {
         if (!mIsVoiceCapable)
             return;
+			
+		 // Fake RIL_UNSOL_CALL_RING if the RIL doesn't send it.
+        // Note that we need the delay to prevent the request from
+        // being sent after CallTracker detects "RINGING" state, but
+        // before the correct contact-specific ringtone is queried.
+        // Otherwise, the incorrect ringtone will be used
+        if (!mDoesRilSendCallRing) {
+            int token = ++mCallRingContinueToken;
+            sendMessageDelayed(
+                    obtainMessage(EVENT_CALL_RING_CONTINUE, token, 0), mCallRingDelay);
+        }
+
         AsyncResult ar = new AsyncResult(null, cn, null);
         mNewRingingConnectionRegistrants.notifyRegistrants(ar);
     }
@@ -1522,6 +1540,7 @@
         pw.println(" mDnsCheckDisabled=" + mDnsCheckDisabled);
         pw.println(" mDcTracker=" + mDcTracker);
         pw.println(" mDoesRilSendMultipleCallRing=" + mDoesRilSendMultipleCallRing);
+		 pw.println(" mDoesRilSendCallRing=" + mDoesRilSendCallRing);
         pw.println(" mCallRingContinueToken=" + mCallRingContinueToken);
         pw.println(" mCallRingDelay=" + mCallRingDelay);
         pw.println(" mIsTheCurrentActivePhone=" + mIsTheCurrentActivePhone);
diff -ur CM11_loganxx/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/CardSubscriptionManager.java CM11_loganxxP/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/CardSubscriptionManager.java
--- CM11_loganxx/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/CardSubscriptionManager.java	2016-02-19 12:52:25.000000000 +0000
+++ CM11_loganxxP/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/CardSubscriptionManager.java	2016-02-22 18:56:41.000000000 +0000
@@ -143,11 +143,13 @@
 
 
     //***** Events
-    private static final int EVENT_RADIO_NOT_AVAILABLE = 1;
+    private static final int EVENT_RADIO_OFF_OR_NOT_AVAILABLE = 0;
+    private static final int EVENT_RADIO_ON = 1;
     private static final int EVENT_ICC_CHANGED = 2;
     private static final int EVENT_GET_ICCID_DONE = 3;
     private static final int EVENT_UPDATE_UICC_STATUS = 4;
     private static final int EVENT_SIM_REFRESH = 5;
+	 private static final int EVENT_RADIO_NOT_AVAILABLE = 6;
 
     //***** Class Variables
     private static CardSubscriptionManager sCardSubscriptionManager;
@@ -156,6 +158,7 @@
     private CommandsInterface[] mCi;
     private MSimUiccController mUiccController;
     private int mNumPhones = MSimTelephonyManager.getDefault().getPhoneCount();
+	 private boolean[] mRadioOn = new boolean[mNumPhones];
     private boolean[] mSubActivated = new boolean[mNumPhones];
 
     private int mUpdateUiccStatusContext = 0;
@@ -203,10 +206,13 @@
         for (int i = 0; i < mCi.length; i++) {
             // Register for Subscription ready event for both the subscriptions.
             Integer slot = new Integer(i);
+			 mCi[i].registerForOffOrNotAvailable(this, EVENT_RADIO_OFF_OR_NOT_AVAILABLE, slot);
             mCi[i].registerForNotAvailable(this, EVENT_RADIO_NOT_AVAILABLE, slot);
+			 mCi[i].registerForOn(this, EVENT_RADIO_ON, slot);
 
             // Register for SIM Refresh events
             mCi[i].registerForIccRefresh(this, EVENT_SIM_REFRESH, new Integer(i));
+			 mRadioOn[i] = false;
             mSubActivated[i] = false;
         }
 
@@ -231,6 +237,16 @@
     @Override
     public void handleMessage(Message msg) {
         switch(msg.what) {
+			case EVENT_RADIO_OFF_OR_NOT_AVAILABLE:
+                logd("EVENT_RADIO_OFF_OR_NOT_AVAILABLE");
+                processRadioOffOrNotAvailable((AsyncResult)msg.obj);
+                break;
+
+            case EVENT_RADIO_ON:
+                logd("EVENT_RADIO_ON");
+                processRadioOn((AsyncResult)msg.obj);
+                break;
+
             case EVENT_RADIO_NOT_AVAILABLE:
                 logd("EVENT_RADIO_NOT_AVAILABLE");
                 processRadioNotAvailable((AsyncResult)msg.obj);
@@ -279,13 +295,36 @@
             loge("processSimRefresh received without input");
         }
     }
+	
+	private void processRadioOffOrNotAvailable(AsyncResult ar) {
+        Integer cardIndex = (Integer)ar.userObj;
+
+        logd("processRadioOffOrNotAvailable on cardIndex = " + cardIndex);
+
+        if (cardIndex >= 0 && cardIndex < mRadioOn.length) {
+            mRadioOn[cardIndex] = false;
+            //If sub is deactivated then reset card info.
+            if (mSubActivated[cardIndex] == false) {
+                resetCardInfo(cardIndex);
+                //CardInfo is not valid. Inform others that card info not available.
+                notifyCardInfoNotAvailable(cardIndex,
+                        CardUnavailableReason.REASON_RADIO_UNAVAILABLE);
+                // Reset the flag card info available to false, so that
+                // next time it notifies all cards info available.
+                mAllCardsInfoAvailable = false;
+            }
+        } else {
+            logd("Invalid Index!!!");
+        }
+    }
 
     private void processRadioNotAvailable(AsyncResult ar) {
         Integer cardIndex = (Integer)ar.userObj;
 
         logd("processRadioNotAvailable on cardIndex = " + cardIndex);
 
-        if (cardIndex >= 0 && cardIndex < mNumPhones) {
+        if (cardIndex >= 0 && cardIndex < mRadioOn.length) {
+            mRadioOn[cardIndex] = false;
             //Radio unavailable comes in case of rild crash or Modem SSR.
             //reset card info in case of radio Unavailable in order to send SET_UICC later.
             resetCardInfo(cardIndex);
@@ -300,6 +339,18 @@
             logd("Invalid Index!!!");
         }
     }
+	
+	private void processRadioOn(AsyncResult ar) {
+        Integer cardIndex = (Integer)ar.userObj;
+
+        logd("processRadioOn on cardIndex = " + cardIndex);
+
+        if (cardIndex >= 0 && cardIndex < mRadioOn.length) {
+            mRadioOn[cardIndex] = true;
+        } else {
+            logd("Invalid Index!!!");
+        }
+    }
 
     /**
      * Process the ICC_CHANGED notification.
@@ -312,6 +363,10 @@
 
         if ((ar.exception == null) && (ar.result != null)) {
             Integer cardIndex = (Integer) ar.result;
+			if (!mRadioOn[cardIndex]) {
+                logd("handleIccChanged: radio not available - EXIT");
+                return;
+            }
             UiccCard uiccCard = mUiccController.getUiccCards()[cardIndex];
             UiccCard card = mUiccCardList.get(cardIndex).getUiccCard();
 
@@ -450,6 +505,11 @@
         }
 
         logd("handleGetIccIdDone: cardIndex = " + cardIndex);
+		
+		if (!mRadioOn[cardIndex]) {
+            logd("handleGetIccIdDone: radio not available - EXIT");
+            return;
+        }
 
         String iccId = null;
 
@@ -588,7 +648,8 @@
             uiccCard = cardInfo.getUiccCard();
         }
 
-        if (uiccCard == null) {
+        if (uiccCard == null || mRadioOn[cardIndex] == false) {
+            logd("onUpdateUiccStatus(): mRadioOn[" + cardIndex + "] = " + mRadioOn[cardIndex]);
             logd("onUpdateUiccStatus(): NO Card!!!!! at index : " + cardIndex);
             if (mCardSubData[cardIndex] != null) {
                 // Card is removed.
@@ -713,7 +774,7 @@
 
         // Required to notify only once!!!
         // Notify if all card info is available.
-        if (isValidCards() && !mAllCardsInfoAvailable) {
+        if (isValidCards() && !mAllCardsInfoAvailable && mRadioOn[cardIndex]) {
             mAllCardsInfoAvailable = true;
             notifyAllCardsInfoAvailable();
         }
diff -ur CM11_loganxx/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimCDMALTEPhone.java CM11_loganxxP/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimCDMALTEPhone.java
--- CM11_loganxx/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimCDMALTEPhone.java	2016-02-19 12:52:25.000000000 +0000
+++ CM11_loganxxP/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimCDMALTEPhone.java	2016-02-22 18:57:12.000000000 +0000
@@ -99,7 +99,6 @@
                 this, EVENT_SUBSCRIPTION_ACTIVATED, null);
         subMgr.registerForSubscriptionDeactivated(mSubscription,
                 this, EVENT_SUBSCRIPTION_DEACTIVATED, null);
-        mSubscriptionData = subMgr.getCurrentSubscription(mSubscription);
     }
 
     @Override
diff -ur CM11_loganxx/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimGSMPhone.java CM11_loganxxP/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimGSMPhone.java
--- CM11_loganxx/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimGSMPhone.java	2016-02-19 12:52:25.000000000 +0000
+++ CM11_loganxxP/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimGSMPhone.java	2016-02-22 18:57:23.000000000 +0000
@@ -85,7 +85,6 @@
                 this, EVENT_SUBSCRIPTION_ACTIVATED, null);
         subMgr.registerForSubscriptionDeactivated(mSubscription,
                 this, EVENT_SUBSCRIPTION_DEACTIVATED, null);
-        mSubscriptionData = subMgr.getCurrentSubscription(mSubscription);
 
         setProperties();
     }
diff -ur CM11_loganxx/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimUiccController.java CM11_loganxxP/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimUiccController.java
--- CM11_loganxx/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimUiccController.java	2016-02-19 12:52:25.000000000 +0000
+++ CM11_loganxxP/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimUiccController.java	2016-02-22 18:57:35.000000000 +0000
@@ -157,7 +157,6 @@
             Integer index = new Integer(i);
             mCis[i].registerForIccStatusChanged(this, EVENT_ICC_STATUS_CHANGED, index);
             // TODO remove this once modem correctly notifies the unsols
-            mCis[i].registerForAvailable(this, EVENT_ICC_STATUS_CHANGED, index);
             mCis[i].registerForOn(this, EVENT_ICC_STATUS_CHANGED, index);
             mCis[i].registerForNotAvailable(this, EVENT_RADIO_UNAVAILABLE, index);
         }
diff -ur CM11_loganxx/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/SubscriptionManager.java CM11_loganxxP/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/SubscriptionManager.java
--- CM11_loganxx/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/SubscriptionManager.java	2016-02-19 12:52:25.000000000 +0000
+++ CM11_loganxxP/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/SubscriptionManager.java	2016-02-22 18:58:15.000000000 +0000
@@ -164,6 +164,7 @@
 
     private boolean[] mCardInfoAvailable = new boolean[mNumPhones];
     private boolean[] mIsNewCard = new boolean[mNumPhones];
+	private boolean[] mRadioOn = new boolean[mNumPhones];
 
     private HashMap<SubscriptionId, Subscription> mActivatePending;
     private HashMap<SubscriptionId, Subscription> mDeactivatePending;
@@ -272,6 +273,7 @@
 
             mCardInfoAvailable[i] = false;
             mIsNewCard[i] = false;
+			mRadioOn[i] = false;
         }
 
         mSubDeactivatedRegistrants = new RegistrantList[mNumPhones];
@@ -323,15 +325,21 @@
                 ar = (AsyncResult)msg.obj;
                 subId = (Integer)ar.userObj;
                 logd("EVENT_RADIO_OFF_OR_NOT_AVAILABLE on SUB: " + subId);
-                mSetSubscriptionInProgress = false;
-                mSetDdsRequired = true;
+                mRadioOn[subId] = false;
+                if (!isAllRadioOn()) {
+                    mSetSubscriptionInProgress = false;
+                    mSetDdsRequired = true;
+                }
                 break;
 
             case EVENT_RADIO_ON:
                 ar = (AsyncResult)msg.obj;
                 subId = (Integer)ar.userObj;
                 logd("EVENT_RADIO_ON on SUB: " + subId);
-                sendDefaultSubsInfo();
+                mRadioOn[subId] = true;
+                if (isAllRadioOn()) {
+                   sendDefaultSubsInfo();
+                }
                 break;
 
             case EVENT_CARD_INFO_AVAILABLE:
@@ -581,6 +589,10 @@
      * @param ar
      */
     private void processCleanupDataConnectionDone(Integer subId) {
+		if (!mRadioOn[subId]) {
+           logd("processCleanupDataConnectionDone: Radio Not Available on subId = " + subId);
+           return;
+        }
         // Cleanup data connection is done!  Start processing the
         // pending deactivate requests now.
         mDataActive = false;
@@ -598,6 +610,11 @@
         boolean isSubReady = mCurrentSubscriptions.get(sub).subReady;
         logd("processSubscriptionStatusChanged sub = " + subId
                 + " actStatus = " + actStatus);
+		
+		if (!mRadioOn[subId]) {
+           logd("processSubscriptionStatusChanged: Radio Not Available on subId = " + subId);
+           return;
+        }
 
         if ((isSubReady == true && actStatus == SUB_STATUS_ACTIVATED) ||
                 (isSubReady == false && actStatus == SUB_STATUS_DEACTIVATED)) {
@@ -661,6 +678,12 @@
         String cause = null;
         SubscriptionStatus subStatus = SubscriptionStatus.SUB_INVALID;
         Subscription currentSub = null;
+		
+		if (!mRadioOn[setSubParam.subId]) {
+           logd("processSetUiccSubscriptionDone: Radio Not Available on subId = "
+                + setSubParam.subId);
+           return;
+        }
 
         if (setSubParam.appType.equals("GLOBAL") &&
                 (setSubParam.subStatus == SubscriptionStatus.SUB_ACTIVATE)) {
@@ -1000,6 +1023,10 @@
      * Handles EVENT_ALL_CARDS_INFO_AVAILABLE.
      */
     private void processAllCardsInfoAvailable() {
+		if (!isAllRadioOn()) {
+           logd("processAllCardsInfoAvailable: Radio Not Available ");
+           return;
+        }
         int availableCards = 0;
         mAllCardsStatusAvailable = true;
 
@@ -1028,6 +1055,10 @@
      * Handles EVENT_PROCESS_AVAILABLE_CARDS
      */
     private void processAvailableCards() {
+		 if (!isAllRadioOn()) {
+           logd("processAvailableCards: Radio Not Available ");
+           return;
+        }
         if (mSetSubscriptionInProgress) {
            logd("processAvailableCards: set subscription in progress!!");
            return;
@@ -1143,6 +1174,11 @@
      */
     private void processCardInfoAvailable(AsyncResult ar) {
         Integer cardIndex = (Integer)ar.userObj;
+		
+		 if (!mRadioOn[cardIndex]) {
+           logd("processCardInfoAvailable: Radio Not Available on cardIndex = " + cardIndex);
+           return;
+        }
 
         mCardInfoAvailable[cardIndex] = true;
 
@@ -1195,6 +1231,14 @@
 
         mContext.startActivity(setSubscriptionIntent);
     }
+	
+	private boolean isAllRadioOn() {
+        boolean result = true;
+        for (boolean radioOn : mRadioOn) {
+            result = result && radioOn;
+        }
+        return result;
+    }
 
     private boolean isAllCardsInfoAvailable() {
         boolean result = true;
diff -ur CM11_loganxx/hardware/broadcom/libbt/src/userial_vendor.c CM11_loganxxP/hardware/broadcom/libbt/src/userial_vendor.c
--- CM11_loganxx/hardware/broadcom/libbt/src/userial_vendor.c	2016-02-19 12:52:26.000000000 +0000
+++ CM11_loganxxP/hardware/broadcom/libbt/src/userial_vendor.c	2016-02-22 18:59:05.000000000 +0000
@@ -182,6 +182,10 @@
     uint8_t data_bits;
     uint16_t parity;
     uint8_t stop_bits;
+	
+	#if (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
+    int ldisc;
+	#endif
 
     vnd_userial.fd = -1;
 
@@ -252,6 +256,12 @@
     tcsetattr(vnd_userial.fd, TCSANOW, &vnd_userial.termios);
 
 #if (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
+	 // TODO: check for breakage on tuna (Galaxy Nexus). It defines this,
+    // but does not contain the kernel code to support it.
+    // Switch to N_BRCM_HCI line disclipline for ioctl to work
+    ldisc = 25; // N_BRCM_HCI
+    ioctl(vnd_userial.fd, TIOCSETD, &ldisc);
+
     userial_ioctl_init_bt_wake(vnd_userial.fd);
 #endif
 
diff -ur CM11_loganxx/packages/apps/Settings/res/xml/multi_sim_settings.xml CM11_loganxxP/packages/apps/Settings/res/xml/multi_sim_settings.xml
--- CM11_loganxx/packages/apps/Settings/res/xml/multi_sim_settings.xml	2016-02-19 12:52:42.000000000 +0000
+++ CM11_loganxxP/packages/apps/Settings/res/xml/multi_sim_settings.xml	2016-02-22 19:00:24.000000000 +0000
@@ -31,16 +31,6 @@
 <PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android"
         xmlns:settings="http://schemas.android.com/apk/res/com.android.settings">
 
-    <PreferenceScreen
-        android:key="config_sub"
-        android:title="@string/sel_sub_title"
-        android:summary="@string/sel_sub_summary"
-        android:persistent="false">
-        <intent android:action="android.intent.action.MAIN"
-                android:targetPackage="com.android.phone"
-                android:targetClass="com.android.phone.SetSubscription" />
-    </PreferenceScreen>
-
     <CheckBoxPreference
         android:key="tune_away"
         android:title="@string/tune_away_title"
diff -ur CM11_loganxx/packages/apps/Settings/src/com/android/settings/MultiSimSettings.java CM11_loganxxP/packages/apps/Settings/src/com/android/settings/MultiSimSettings.java
--- CM11_loganxx/packages/apps/Settings/src/com/android/settings/MultiSimSettings.java	2016-02-19 12:52:42.000000000 +0000
+++ CM11_loganxxP/packages/apps/Settings/src/com/android/settings/MultiSimSettings.java	2016-02-22 19:01:44.000000000 +0000
@@ -101,7 +101,6 @@
     private ListPreference mVoice;
     private ListPreference mData;
     private ListPreference mSms;
-    private PreferenceScreen mConfigSub;
     private CharSequence[] entries; // Used for entries like Subscription1, Subscription2 ...
     private CharSequence[] entryValues; // Used for entryValues like 0, 1 ,2 ...
     private CharSequence[] summaries; // Used for Summaries like Aubscription1, Subscription2....
@@ -142,8 +141,6 @@
         mData.setOnPreferenceChangeListener(this);
         mSms = (ListPreference) findPreference(KEY_SMS);
         mSms.setOnPreferenceChangeListener(this);
-        mConfigSub = (PreferenceScreen) findPreference(KEY_CONFIG_SUB);
-        mConfigSub.getIntent().putExtra(CONFIG_SUB, true);
         mTuneAway = (CheckBoxPreference) findPreference(TUNE_AWAY);
         mTuneAway.setOnPreferenceChangeListener(this);
         mPrioritySub = (ListPreference) findPreference(PRIORITY_SUB);
@@ -230,14 +227,9 @@
         Log.d(TAG, "mIccCardCount = " + mIccCardCount);
 
         if (mIccCardCount == 0) {
-             mConfigSub.setEnabled(false);
-             mConfigSub.setSelectable(false);
              displayAlertDialog(getResources().getString(R.string.no_sim_info));
              configureMSimMenu(false);
         } else if (mIccCardCount == 1) {
-             //1 SIM card is present. Config sub must be accessible
-             mConfigSub.setEnabled(true);
-             mConfigSub.setSelectable(true);
              configureMSimMenu(false);
         } else if ( (mIccCardCount > 1) && (mIccCardCount <= MAX_SUBSCRIPTIONS) )  {
             configureMSimMenu(true);
@@ -591,11 +583,6 @@
                     }
 
                     break;
-                case EVENT_SUBSCRIPTION_ACTIVATED:
-                case EVENT_SUBSCRIPTION_DEACTIVATED:
-                    updateMultiSimEntriesForVoice();
-                    updateMultiSimEntriesForSms();
-                    break;
 
                 case EVENT_SET_VOICE_SUBSCRIPTION:
                     if (!mHasTuneAway) {
diff -ur CM11_loganxx/packages/services/Telephony/src/com/android/phone/CallFeaturesSetting.java CM11_loganxxP/packages/services/Telephony/src/com/android/phone/CallFeaturesSetting.java
--- CM11_loganxx/packages/services/Telephony/src/com/android/phone/CallFeaturesSetting.java	2016-02-19 12:52:45.000000000 +0000
+++ CM11_loganxxP/packages/services/Telephony/src/com/android/phone/CallFeaturesSetting.java	2016-02-22 19:03:14.000000000 +0000
@@ -60,6 +60,7 @@
 import android.provider.ContactsContract.CommonDataKinds;
 import android.provider.MediaStore;
 import android.provider.Settings;
+import android.telephony.MSimTelephonyManager;
 import android.telephony.PhoneNumberUtils;
 import android.text.TextUtils;
 import android.util.Log;
@@ -2693,10 +2694,15 @@
      * This is useful for implementing "HomeAsUp" capability for second-level Settings.
      */
     public static void goUpToTopLevelSetting(Activity activity) {
-        Intent intent = new Intent(activity, CallFeaturesSetting.class);
-        intent.setAction(Intent.ACTION_MAIN);
-        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
-        activity.startActivity(intent);
+         if (!MSimTelephonyManager.getDefault().isMultiSimEnabled()) {
+            // HACK: This doesn't work on multi-SIM (and we have multiple)
+            //       hierachy (MSimCallFeaturesSetting and MSimCallFeatureSubSetting)
+            //       so let just allow this to act like "back" button
+            Intent intent = new Intent(activity, CallFeaturesSetting.class);
+            intent.setAction(Intent.ACTION_MAIN);
+            intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
+            activity.startActivity(intent);
+        }
         activity.finish();
     }
 
